## 事件委托

由于事件会在冒泡阶段向上传播到父节点。因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方式叫做事件委托（delegation）。
```javascript
var ul = document.querySelector('ul');
ul.addEventListener('click',function(event){
    if (event.target.tagName.toLowercase() === 'li'){
        //some code
    }
});
```

上面代码中，click事件的监听函数定义在<ul>节点，但是实际上，它处理的是子节点<li>的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<li>节点上定义监听函数。而且以后再添加子节点，监听函数仍然有效。

如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。
```javascript
//事件传播到p元素后，就不再向下传播了
p.addEventListener('click',function (event) {
    event.stopPropagation();
},true);
//事件冒泡到p元素后，就不再向上冒泡了
p.addEventListener('click',function(event) {
    event.stopPropagation();
},false);
```

上面代码中，stopPropagation方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。

但是，stopPropagation方法只会阻止事件的传播，不会阻止该事件触发<p>节点的其他click事件的监听函数。也就是说，不是彻底取消click事件。

```javascript
p.addEventListener('click',function(event) {
    event.stopPropagation();
    console.log(1);
});

p.addEventListener('click',function(event) {
    //会触发
    console.log(2);
});
```

上面代码,p元素绑定了两个click事件的监听函数。stopPropagation方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是1，然后是2。

如果想要彻底取消该事件，不再触发后面所有的click的监听函数，可以使用stopImmediatePropagation方法。

```javascript
p.addEventListener('click',function(event) {
    event.stopImmediatePropagation();
    console.log(1);
});
p.addEventListener('click',function(event) {
    //不会被触发
    console.log(2);
});
```

上面代码中，stopImmediatePropagation方法可以彻底取消这个事件，使得后面绑定的所有click监听函数都不再触发。所以，只会输出1，不会输出2 。

